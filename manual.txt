Step 1 - Installing the modified Wannier90 source
*************************************************

Build your first-principles code with the Wannier90 source given in
Wannier90/wannier90-1.2.0.1.tar.gz

This will break some Wannier90 functionality (the B1 tests in
src/kmesh.F90 have been disabled), so it is recommended that you create
a separate build of the first-principles code.
It would be nice if a future version of Wannier90 could support this
behaviour out of the box. This would require exposing the flag
(now called skip_B1_tests) to the user interface.
All changes to the original kmesh.F90 are marked with
! CHANGE
...
! END CHANGE.


Step 2 - Running Z2Pack
***********************

Basic functionality
-------------------
A basic example for a Z2Pack run can be found in examples/fp/Bi_abinit.

The way Z2Pack works is that it will copy your input files into the
build folder (both to be specified in the code).
Then it calls the command you specify in that build folder, which should
produce the wannier90.mmn file.
So before doing a Z2Pack calculation, you should have the output from
an SCF calculation to use on subsequent runs. When referencing these
output files, file paths should be relative to the build folder.

Generating k-points
-------------------
Because the k-point at which Wannier charge centers will be computed
changes dynamically, you will not have to specify that in your input
files. Instead, you should write a Python function that returns a
string that is your k-points input. This function should take 4 input
variables:

- start_point: the first k-point in the string of k-points
- last_point: the last k-point in the string of k-points
- end_point: the point "just after last_point", i.e. the point connected
  to start_point by a reciprocal lattice vector.
- N: number of k-points

to illustrate (s: start_point, l: last_point, e: end_point):

    s . . . . . . . . l e
    
    {s, ..., l} should be used as k-points, e not, N=10

depending on how your first-principles code works, it will be easier to
work with l or e.

You can then specify in which file this output should go. If the file
already exists as one of your input files, it will be appended, other-
wise a new file will be created.

For use with Abinit, you can use the function z2pack.fp.kpts.abinit,
for quantum espresso use z2pack.fp.kpts.qe and z2pack.fp.kpts.wannier90.

Running it...
-------------
Once you have run your SCF calculation, created your input files and
the function generating k-points, you should modify the skeleton code
in examples/fp/QuantumEspresso/QE.py to run a Wannier charge center
calculation. examples/fp/QuantumEspresso/QE_plot.py, on the other hand,
is a minimalistic skeleton code for plotting the WCC and calculating
the Z2 topological invariant.

References
**********
Because the website that will contain the documentation is not up yet, I
included an HTML file doc/build/html/doc.html which contains the
documentation and can be viewed with any web browser.
If you have any kind of problems or suggestions, feel free to contact me
at greschd@ethz.ch
